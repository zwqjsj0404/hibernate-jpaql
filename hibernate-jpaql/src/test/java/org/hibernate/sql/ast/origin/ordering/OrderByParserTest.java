/*
 * Copyright (c) 2009, Red Hat Middleware LLC or third-party contributors as
 * indicated by the @author tags or express copyright attribution
 * statements applied by the authors.  All third-party contributions are
 * distributed under license by Red Hat Middleware LLC.
 *
 * This copyrighted material is made available to anyone wishing to use, modify,
 * copy, or redistribute it subject to the terms and conditions of the GNU
 * Lesser General Public License, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this distribution; if not, write to:
 * Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301  USA
 */
package org.hibernate.sql.ast.origin.ordering;

import java.util.Collections;
import java.util.Map;

import junit.framework.TestCase;
import junit.framework.AssertionFailedError;

import org.hibernate.persister.entity.PropertyMapping;
import org.hibernate.QueryException;
import org.hibernate.Hibernate;
import org.hibernate.HibernateException;
import org.hibernate.dialect.Dialect;
import org.hibernate.dialect.HSQLDialect;
import org.hibernate.dialect.function.SQLFunctionRegistry;
import org.hibernate.dialect.function.SQLFunction;
import org.hibernate.dialect.function.SQLFunctionTemplate;
import org.hibernate.engine.SessionFactoryImplementor;
import org.hibernate.sql.ast.util.ASTUtil;
import org.hibernate.sql.ast.util.TreePrinter;
import org.hibernate.sql.ast.origin.hql.parse.HQLLexer;
import org.hibernate.sql.Template;
import org.hibernate.type.Type;

import org.antlr.runtime.ANTLRStringStream;
import org.antlr.runtime.CommonTokenStream;
import org.antlr.runtime.tree.Tree;
import org.antlr.runtime.tree.CommonTree;

/**
 * Assertions against the structures generated by various paths of the "order-by" mapping fragment parser.
 *
 * @author Steve Ebersole
 */
public class OrderByParserTest extends TestCase {
	public static final PropertyMapping STANDARD_PROPERTY_MAPPING = new PropertyMapping() {
		public String[] toColumns(String propertyName) throws QueryException, UnsupportedOperationException {
			if ( "component".equals( propertyName ) ) {
				return new String[] { "comp_1", "comp_2" };
			}
			else if ( "component.prop1".equals( propertyName ) ) {
				return new String[] { "comp_1" };
			}
			else if ( "component.prop2".equals( propertyName ) ) {
				return new String[] { "comp_2" };
			}
			else if ( "property".equals( propertyName ) ) {
				return new String[] { "prop" };
			}
			throw new QueryException( "could not resolve property: " + propertyName );
		}

		public Type toType(String propertyName) throws QueryException {
			throw new UnsupportedOperationException( "toType(propertyName) not supported here" );
		}

		public String[] toColumns(String alias, String propertyName) throws QueryException {
			throw new UnsupportedOperationException( "toColumns(alias,propertyName) not supported here" );
		}

		public Type getType() {
			throw new UnsupportedOperationException( "getType() not supported here" );
		}
	};

	public static final ColumnMapper STANDARD_MAPPER = new ColumnMapper() {
		public String[] map(String reference) {
			return STANDARD_PROPERTY_MAPPING.toColumns( reference );
		}
	};

	public OrderByParserTest() {
	}

	public OrderByParserTest(String name) {
		super( name );
	}

    public void testSQLReferences() {
        String fragment = "sql asc, sql desc";
        CommonTree tree = parse( fragment );

		assertRootStructure( tree, 2 );

		Tree firstSortSpec = tree.getChild( 0 );
		assertTokenType( HQLLexer.SORT_SPEC, firstSortSpec );
		assertEquals( 2, firstSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, firstSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, firstSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, firstSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.IDENTIFIER, firstSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "sql", firstSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, firstSortSpec.getChild( 1 ) );
		assertEquals( "asc", firstSortSpec.getChild( 1 ).getText() );

		Tree secondSortSpec = tree.getChild( 1 );
		assertTokenType( HQLLexer.SORT_SPEC, secondSortSpec.getType() );
		assertEquals( 2, secondSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, secondSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, secondSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, secondSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.IDENTIFIER, secondSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "sql", secondSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, secondSortSpec.getChild( 1 ) );
		assertEquals( "desc", secondSortSpec.getChild( 1 ).getText() );
    }

    public void testQuotedSQLReferences() {
        String fragment = "`sql` asc, `sql` desc";
        CommonTree tree = parse( fragment );

		assertRootStructure( tree, 2 );

		Tree firstSortSpec = tree.getChild( 0 );
		assertTokenType( HQLLexer.SORT_SPEC, firstSortSpec.getType() );
		assertEquals( 2, firstSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, firstSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, firstSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, firstSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.QUOTED_IDENTIFIER, firstSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "`sql`", firstSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, firstSortSpec.getChild( 1 ) );
		assertEquals( "asc", firstSortSpec.getChild( 1 ).getText() );

		Tree secondSortSpec = tree.getChild( 1 );
		assertTokenType( HQLLexer.SORT_SPEC, secondSortSpec.getType() );
		assertEquals( 2, secondSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, secondSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, secondSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, secondSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.QUOTED_IDENTIFIER, secondSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "`sql`", secondSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, secondSortSpec.getChild( 1 ) );
		assertEquals( "desc", secondSortSpec.getChild( 1 ).getText() );
    }

    public void testPropertyReference() {
		String fragment = "property asc, property desc";
        CommonTree tree = parse( fragment );

		assertRootStructure( tree, 2 );

		Tree firstSortSpec = tree.getChild( 0 );
		assertTokenType( HQLLexer.SORT_SPEC, firstSortSpec.getType() );
		assertEquals( 2, firstSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, firstSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, firstSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, firstSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.IDENTIFIER, firstSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "prop", firstSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, firstSortSpec.getChild( 1 ) );
		assertEquals( "asc", firstSortSpec.getChild( 1 ).getText() );

		Tree secondSortSpec = tree.getChild( 1 );
		assertTokenType( HQLLexer.SORT_SPEC, secondSortSpec.getType() );
		assertEquals( 2, secondSortSpec.getChildCount() );
		assertTokenType( HQLLexer.COLUMN, secondSortSpec.getChild( 0 ) );
		assertTokenType( HQLLexer.ALIAS_REF, secondSortSpec.getChild( 0 ).getChild( 0 ) );
		assertEquals( Template.TEMPLATE, secondSortSpec.getChild( 0 ).getChild( 0 ).getText() );
		assertTokenType( HQLLexer.IDENTIFIER, secondSortSpec.getChild( 0 ).getChild( 1 ) );
		assertEquals( "prop", secondSortSpec.getChild( 0 ).getChild( 1 ).getText() );
		assertTokenType( HQLLexer.ORDER_SPEC, secondSortSpec.getChild( 1 ) );
		assertEquals( "desc", secondSortSpec.getChild( 1 ).getText() );
	}

    public void testFunctionReference() {
		String fragment = "upper(sql) asc, lower(sql) desc";
		CommonTree tree = parse( fragment );

		assertRootStructure( tree, 2 );

		Tree firstSortSpec = tree.getChild( 0 );
		assertTokenType( HQLLexer.SORT_SPEC, firstSortSpec.getType() );
		assertEquals( 2, firstSortSpec.getChildCount() );
		assertTokenType( HQLLexer.UPPER, firstSortSpec.getChild( 0 ) );
		assertEquals( 1, firstSortSpec.getChild( 0 ).getChildCount() );
		assertTokenType( HQLLexer.COLUMN, firstSortSpec.getChild( 0 ).getChild( 0 ) );
		assertTokenType( HQLLexer.IDENTIFIER, firstSortSpec.getChild( 0 ).getChild( 0 ).getChild( 1 ) );
		assertEquals( "sql", firstSortSpec.getChild( 0 ).getChild( 0 ).getChild( 1 ).getText() );
		assertEquals( "asc", firstSortSpec.getChild( 1 ).getText() );

		Tree secondSortSpec = tree.getChild( 1 );
		assertTokenType( HQLLexer.SORT_SPEC, secondSortSpec.getType() );
		assertEquals( 2, secondSortSpec.getChildCount() );
		assertTokenType( HQLLexer.LOWER, secondSortSpec.getChild( 0 ) );
		assertEquals( 1, secondSortSpec.getChild( 0 ).getChildCount() );
		assertTokenType( HQLLexer.COLUMN, secondSortSpec.getChild( 0 ).getChild( 0 ) );
		assertTokenType( HQLLexer.IDENTIFIER, secondSortSpec.getChild( 0 ).getChild( 0 ).getChild( 1 ) );
		assertEquals( "sql", secondSortSpec.getChild( 0 ).getChild( 0 ).getChild( 1 ).getText() );
		assertEquals( "desc", secondSortSpec.getChild( 1 ).getText() );
	}

	protected CommonTree parse(String orderByFragment) {
		final Dialect dialect = new HSQLDialect();
		final SQLFunction myFunction = new SQLFunctionTemplate( Hibernate.STRING, "myFunction($1)" );
		final SQLFunctionRegistry functionRegistry = new SQLFunctionRegistry( dialect, Collections.singletonMap( "myFunction", myFunction ) );
		return parse(
				orderByFragment,
				new TranslationContext() {
					public SessionFactoryImplementor getSessionFactory() {
						return null;
					}

					public Dialect getDialect() {
						return dialect;
					}

					public SQLFunctionRegistry getSqlFunctionRegistry() {
						return functionRegistry;
					}

					public ColumnMapper getColumnMapper() {
						return STANDARD_MAPPER;
					}
				}
		);
	}

	private static final TreePrinter TREE_PRINTER = new TreePrinter( HQLLexer.class );

	protected CommonTree parse(String orderByFragment, TranslationContext context) {
		try {
			HQLLexer lexer = new HQLLexer( new ANTLRStringStream( orderByFragment ) );
			ContextualOrderByParser parser = new ContextualOrderByParser( new CommonTokenStream( lexer ), context );
			CommonTree rtn = parser.orderByFragment().tree;
			// temp
			System.out.println(
					TREE_PRINTER.renderAsString( rtn, "fragment" )
			);
			return rtn;
		}
		catch ( HibernateException e ) {
			throw e;
		}
		catch ( Throwable t ) {
			throw new HibernateException( "Unable to parse order-by fragment", t );
		}
	}

	private static final Map<Integer,String> tokenNameMap = ( Map<Integer,String> ) ASTUtil.generateTokenNameCache( HQLLexer.class );

	public void assertTokenType(int expected, int actual) {
		if ( expected != actual ) {
			throw new AssertionFailedError(
					"expected:<"+ tokenNameMap.get( expected ) +"> but was:<"+ tokenNameMap.get( actual ) +">"
			);
		}
	}

	public void assertTokenType(int expected, Tree tree) {
		if ( tree == null ) {
			throw new AssertionFailedError(
					"expected:<"+ tokenNameMap.get( expected ) +"> but was:<null>"
			);
		}
		assertTokenType( expected, tree.getType() );
	}

	public void assertRootStructure(Tree tree, int expectedSortSpecCount) {
		assertTokenType( HQLLexer.ORDER_BY, tree.getType() );
		assertEquals( expectedSortSpecCount, tree.getChildCount() );
	}
}
