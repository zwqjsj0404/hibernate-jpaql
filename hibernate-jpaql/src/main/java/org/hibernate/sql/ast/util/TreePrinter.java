/*
 * Hibernate, Relational Persistence for Idiomatic Java
 *
 * Copyright (c) 2008, Red Hat Middleware LLC or third-party contributors as
 * indicated by the @author tags or express copyright attribution
 * statements applied by the authors.  All third-party contributions are
 * distributed under license by Red Hat Middleware LLC.
 *
 * This copyrighted material is made available to anyone wishing to use, modify,
 * copy, or redistribute it subject to the terms and conditions of the GNU
 * Lesser General Public License, as published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
 * or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this distribution; if not, write to:
 * Free Software Foundation, Inc.
 * 51 Franklin Street, Fifth Floor
 * Boston, MA  02110-1301  USA
 */
package org.hibernate.sql.ast.util;

import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.Map;

import org.hibernate.util.StringHelper;
import org.antlr.runtime.tree.Tree;

/**
 * Utility for generating pretty "ASCII art" representations of syntax trees.
 *
 * @author Joshua Davis
 * @author Steve Ebersole
 */
public class TreePrinter {
	private final Map tokenTypeNameCache;
	private final boolean showClassNames;

	/**
	 * Constructs a printer.
	 * <p/>
	 * Delegates to {@link #TreePrinter(Class, boolean)} with {@link #isShowClassNames showClassNames} as <tt>false</tt>
	 *
	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
	 * interface generated by ANTLR.
	 */
	public TreePrinter(Class tokenTypeConstants) {
		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), false );
	}

	public TreePrinter(boolean showClassNames) {
		this( ( Map ) null, showClassNames );
	}

	/**
	 * Constructs a printer.
	 *
	 * @param tokenTypeConstants The token types to use during printing; typically the {vocabulary}TokenTypes.java
	 * interface generated by ANTLR.
	 * @param showClassNames Should the class names of the tree nodes impls be displayed.
	 */
	public TreePrinter(Class tokenTypeConstants, boolean showClassNames) {
		this( ASTUtil.generateTokenNameCache( tokenTypeConstants ), showClassNames );
	}

	private TreePrinter(Map tokenTypeNameCache, boolean showClassNames) {
		this.tokenTypeNameCache = tokenTypeNameCache;
		this.showClassNames = showClassNames;
	}

	/**
	 * Getter for property 'showClassNames'.
	 *
	 * @return Value for property 'showClassNames'.
	 */
	public boolean isShowClassNames() {
		return showClassNames;
	}

	/**
	 * Renders the tree into 'ASCII art' form and returns that string representation.
	 *
	 * @param tree The tree to display.
	 * @param header The header for the display.
	 *
	 * @return The'ASCII art' form, as a string.
	 */
	public String renderAsString(Tree tree, String header) {
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream( baos );
		ps.println( header );
		render( tree, ps );
		ps.flush();
		return new String( baos.toByteArray() );
	}

	/**
	 * Prints the tree in 'ASCII art' form to the specified print stream.
	 *
	 * @param tree The tree to print.
	 * @param out The print stream to which the tree should be printed.
	 */
	public void render(Tree tree, PrintStream out) {
		render( tree, new PrintWriter( out ) );
	}

	/**
	 * Prints the tree in 'ASCII art' tree form to the specified print writer.
	 *
	 * @param tree The tree to print.
	 * @param pw The print writer to which the tree should be written.
	 */
	public void render(Tree tree, PrintWriter pw) {
		ArrayList parents = new ArrayList();
		render( parents, pw, tree );
		pw.flush();
	}

	/**
	 * Returns the token type name for the given token type.
	 *
	 * @param type The token type.
	 * @return String - The token type name from the token type constant class,
	 *         or just the integer as a string if none exists.
	 */
	public String getTokenTypeName(int type) {
		final Integer typeInteger = new Integer( type );
		String value = null;
		if ( tokenTypeNameCache != null ) {
			value = ( String ) tokenTypeNameCache.get( typeInteger );
		}
		if ( value == null ) {
			value = typeInteger.toString();
		}
		return value;
	}

	private void render(ArrayList parents, PrintWriter pw, Tree tree) {
		if ( tree == null ) {
			pw.println( "tree is null!" );
			return;
		}

        // Tree.getChildIndex() -> the tree's position within its parent's children...

		for ( int i = 0; i < parents.size(); i++ ) {
			final Tree parent = ( Tree ) parents.get( i );
            if ( hasNextSibling( parent ) ) {
				pw.print( "   " );
			}
			else {
				pw.print( " | " );
			}
		}

		if ( hasNextSibling( tree ) ) {
			pw.print( " \\-" );
		}
		else {
			pw.print( " +-" );
		}

		writeNode( pw, tree );

		ArrayList newParents = new ArrayList( parents );
		newParents.add( tree );
        for ( int i = 0; i < tree.getChildCount(); i++ ) {
            render( newParents, pw, tree.getChild( i ) );
        }
		newParents.clear();
	}

    private boolean hasNextSibling(Tree tree) {
        return tree.getParent() != null
                && tree.getParent().getChildCount() <= tree.getChildIndex();
    }

	private void writeNode(PrintWriter pw, Tree tree) {
		pw.println( nodeToString( tree ) );
	}

    private String nodeToString(Tree tree) {
        if ( tree == null ) {
			return "{node:null}";
		}

		StringBuffer buf = new StringBuffer();
		buf.append( "[" ).append( getTokenTypeName( tree.getType() ) );
		if ( showClassNames ) {
			buf.append( " (" ).append( StringHelper.unqualify( tree.getClass().getName() ) ).append( ')' );
		}
		buf.append( "] " );

        String text = tree.getText();
		if ( text != null ) {
        	buf.append( "'" );
			appendEscapedMultibyteChars( text, buf );
        	buf.append( "'" );
		}

        if ( tree instanceof DisplayableNode ) {
            DisplayableNode displayableNode = ( DisplayableNode ) tree;
            buf.append( " => " ).append( displayableNode.getDisplayText() );
        }
        return buf.toString();
    }

    public static void appendEscapedMultibyteChars(String text, StringBuffer buf) {
        char[] chars = text.toCharArray();
        for (int i = 0; i < chars.length; i++) {
            char aChar = chars[i];
            if (aChar > 256) {
                buf.append("\\u");
                buf.append(Integer.toHexString(aChar));
            }
            else
                buf.append(aChar);
        }
    }

    public static String escapeMultibyteChars(String text) {
        StringBuffer buf = new StringBuffer();
        appendEscapedMultibyteChars(text,buf);
        return buf.toString();
    }
}
